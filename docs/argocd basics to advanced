# ArgoCD Mastery: From GitOps Basics to Advanced Deployments

ArgoCD is a **GitOps-focused continuous delivery tool for Kubernetes**. It enables declarative deployments, progressive delivery, multi-cluster management, and automated rollbacks—making it a cornerstone of modern cloud‑native workflows.

This article walks from **GitOps fundamentals** to **advanced ArgoCD deployment patterns**, with practical YAML examples and interview-ready insights.

---

## Introduction to GitOps

GitOps is an operational model where **Git is the single source of truth** for infrastructure and application configuration. Kubernetes continuously reconciles what is defined in Git with what is actually running in the cluster.

### Core Principles of GitOps

| Principle                 | Description                                                 |
| ------------------------- | ----------------------------------------------------------- |
| Declarative configuration | Store Kubernetes manifests (YAML / Helm / Kustomize) in Git |
| Automated synchronization | Changes in Git are applied automatically to clusters        |
| Observability             | Continuously compare Git state vs cluster state             |
| Git-based rollbacks       | Revert changes by rolling back Git commits                  |

### Benefits of GitOps

* Version-controlled deployments
* Fully auditable change history
* Faster, safer rollbacks

---

## ArgoCD Architecture

ArgoCD runs as a **Kubernetes-native control plane** that continuously reconciles Git state with live cluster state.

### Key Components

| Component              | Responsibility                                     |
| ---------------------- | -------------------------------------------------- |
| API Server             | Web UI and central management API                  |
| Application Controller | Compares Git vs cluster state and reconciles drift |
| Repository Server      | Fetches and renders Git repositories               |
| Application CRD        | Declarative representation of an application       |
| Dex (optional)         | SSO and identity provider integration              |

---

## Installing ArgoCD

The recommended approach is to install ArgoCD in a **dedicated namespace**.

```bash
kubectl create namespace argocd
kubectl apply -n argocd \
  -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

kubectl port-forward svc/argocd-server -n argocd 8080:443
```

### First-Time Login

```bash
kubectl -n argocd get secret argocd-initial-admin-secret \
  -o jsonpath="{.data.password}" | base64 -d

argocd login localhost:8080 \
  --username admin \
  --password <password>
```

---

## Defining Applications in ArgoCD

An **Application** connects a Git repository to a destination cluster and namespace. It represents a single deployable unit.

### Creating an Application via CLI

```bash
argocd app create web-app \
  --repo https://github.com/myorg/web-app.git \
  --path manifests \
  --dest-server https://kubernetes.default.svc \
  --dest-namespace dev \
  --sync-policy automated
```

### Application CRD Example

```yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: web-app
  namespace: argocd
spec:
  project: default
  source:
    repoURL: https://github.com/myorg/web-app.git
    path: manifests
    targetRevision: HEAD
  destination:
    server: https://kubernetes.default.svc
    namespace: dev
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
```

---

## App of Apps Pattern

The **App of Apps** pattern lets you manage multiple applications hierarchically using a parent Application.

```yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: parent-app
  namespace: argocd
spec:
  source:
    repoURL: https://github.com/myorg/apps.git
    path: parent
  destination:
    server: https://kubernetes.default.svc
    namespace: argocd
```

This approach is ideal for **large microservice platforms**.

---

## Using Helm with ArgoCD

ArgoCD can directly deploy Helm charts from Git repositories.

```yaml
spec:
  source:
    repoURL: https://github.com/myorg/helm-charts.git
    chart: web-app
    targetRevision: 1.0.0
```

Helm is commonly used for **templated deployments** and **versioned releases**.

---

## Using Kustomize with ArgoCD

Kustomize overlays are supported natively, making them ideal for environment-specific configuration.

```yaml
spec:
  source:
    repoURL: https://github.com/myorg/kustomize-app.git
    path: overlays/dev
```

This keeps environment differences clean and manageable.

---

## ApplicationSets: Multi-Cluster & Multi-Environment

ApplicationSets generate multiple Applications from a single template using generators.

```yaml
apiVersion: argoproj.io/v1alpha1
kind: ApplicationSet
metadata:
  name: web-app-set
spec:
  generators:
    - list:
        elements:
          - cluster: cluster1
            namespace: dev
          - cluster: cluster2
            namespace: prod
  template:
    metadata:
      name: '{{cluster}}-web-app'
    spec:
      source:
        repoURL: https://github.com/myorg/web-app.git
        path: manifests
      destination:
        server: '{{cluster}}'
        namespace: '{{namespace}}'
```

This pattern is powerful for **large-scale GitOps automation**.

---

## Sync Policies & Deployment Strategies

### Sync Policies

| Policy    | Description                    |
| --------- | ------------------------------ |
| Automated | Continuously syncs Git changes |
| Manual    | Requires human approval        |
| Prune     | Removes deleted Git resources  |
| Self-heal | Restores drifted resources     |

### Progressive Delivery with Argo Rollouts

```yaml
apiVersion: argoproj.io/v1alpha1
kind: Rollout
metadata:
  name: web-app-rollout
spec:
  strategy:
    canary:
      steps:
        - setWeight: 10
        - pause: { duration: 5m }
        - setWeight: 50
        - pause: { duration: 10m }
```

This enables **controlled, observable deployments**.

---

## Multi-Cluster Management

ArgoCD can manage multiple Kubernetes clusters from a single control plane.

```bash
argocd cluster add <context-name>
```

This centralizes GitOps operations across environments.

---

## Security & RBAC

ArgoCD integrates with SSO providers and supports fine-grained RBAC.

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: argocd
  name: app-manager
rules:
  - apiGroups: ["argoproj.io"]
    resources: ["applications"]
    verbs: ["get", "create", "update", "delete"]
```

A **least-privilege** approach is recommended.

---

## Notifications & Webhooks

ArgoCD can emit notifications for sync events, failures, and health changes.

```yaml
apiVersion: argoproj.io/v1alpha1
kind: Notification
metadata:
  name: web-app-notify
spec:
  template: slack
  triggers:
    - on-sync-succeeded
```

This improves visibility and operational awareness.

---

## Best Practices & Interview Angles

### Recommended Practices

* Use Git as the single source of truth
* Enable automated sync for low-risk services
* Use ApplicationSets for scale
* Combine Helm and Kustomize effectively
* Monitor ArgoCD metrics and logs

### Common Interview Questions

* Explain the App of Apps pattern and its benefits
* How does ArgoCD support progressive delivery?
* Manual vs automated sync—when would you use each?
* How does ArgoCD integrate with Helm and Kustomize?

---

### Final Thought

**ArgoCD operationalizes GitOps by turning Git commits into reliable, observable, and reversible Kubernetes deployments.**
